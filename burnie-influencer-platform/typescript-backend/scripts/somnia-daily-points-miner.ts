#!/usr/bin/env ts-node

import { DataSource } from 'typeorm';
import * as path from 'path';
import { config } from 'dotenv';

// Load environment variables
config({ path: path.join(__dirname, '../.env') });

// Import Season 2 entities
import { SomniaDreamathonMinerPoints } from '../src/models/SomniaDreamathonMinerPoints';

// Define interfaces
interface MinerWallet {
  walletAddress: string;
  createdAt: Date;
}

interface Project {
  id: number;
  name: string;
}

interface MinerCalculation {
  walletAddress: string;
  projectId: number | null;
  name: string | undefined;
  dailyContentGenerated: number;
  dailyContentSold: number;
  dailySalesRevenue: number;
  dailyRevenueShare: number;
  weeklyUptimeRewards: number;
  weeklyTopSellerBonus: number;
  grandPrizeRewards: number;
  dailySalesRank: number | undefined;
  weeklyTopSellerRank: number;
  overallRank: number | undefined;
}

// Season 2 Constants
const REVENUE_SHARE_PERCENTAGE = 0.70; // 70% of sales go to miner
const MIN_UPTIME_FOR_REWARDS = 95; // 95% minimum uptime to qualify

// Weekly rewards (distributed on Tuesdays at 10 AM ET)
const WEEKLY_UPTIME_POOL = 450000; // 450K divided equally among qualifying nodes
const WEEKLY_TOP_SELLER_POOL = 1000000; // 1M distributed proportionally based on sales

// Campaign dates (Nov 18 - Dec 9, 2025)
const CAMPAIGN_START_DATE = new Date('2025-11-18T15:00:00Z'); // 10 AM ET
const CAMPAIGN_END_DATE = new Date('2025-12-09T15:00:00Z'); // 10 AM ET

// Excluded wallets (lowercase)
const EXCLUDED_WALLETS: string[] = [
  // Add wallet addresses here that should be excluded
];

// Excluded wallets from rewards
const EXCLUDE_WALLET_REWARDS: string[] = [
  // Add wallet addresses here that should be excluded from rewards
];

// Database connection
let AppDataSource: DataSource;

class SomniaDailyPointsMinerScript {
  private dataSource: DataSource;
  private allCalculations: MinerCalculation[] = [];

  constructor(dataSource: DataSource) {
    this.dataSource = dataSource;
  }

  /**
   * Check if a wallet address should be excluded from calculations
   */
  private isWalletExcluded(walletAddress: string): boolean {
    return EXCLUDED_WALLETS.includes(walletAddress.toLowerCase());
  }

  /**
   * Check if a wallet address should be excluded from rewards distribution
   */
  private isWalletExcludedFromRewards(walletAddress: string): boolean {
    return EXCLUDE_WALLET_REWARDS.includes(walletAddress.toLowerCase());
  }

  /**
   * Check if today is within the campaign period
   */
  private isWithinCampaignPeriod(): boolean {
    const now = new Date();
    return now >= CAMPAIGN_START_DATE && now <= CAMPAIGN_END_DATE;
  }

  /**
   * Get all miners (users who have generated content via dedicated miner)
   */
  async getMiners(): Promise<MinerWallet[]> {
    const query = `
      SELECT DISTINCT dme."walletAddress", MIN(dme."createdAt") as "createdAt"
      FROM dedicated_miner_executions dme
      WHERE dme."createdAt" >= $1
      GROUP BY dme."walletAddress"
      ORDER BY "createdAt"
    `;

    const miners = await this.dataSource.query(query, [CAMPAIGN_START_DATE]);
    const filteredMiners = miners
      .map((miner: any) => ({
        walletAddress: miner.walletAddress.toLowerCase(),
        createdAt: new Date(miner.createdAt)
      }))
      .filter((miner: MinerWallet) => !this.isWalletExcluded(miner.walletAddress));

    console.log(`üìä Found ${miners.length} total miners, ${filteredMiners.length} after excluding blocked wallets`);
    
    return filteredMiners;
  }

  /**
   * Get all active projects
   */
  async getActiveProjects(): Promise<Project[]> {
    const query = `
      SELECT DISTINCT p.id, p.name
      FROM projects p
      INNER JOIN campaigns c ON c."projectId" = p.id
      WHERE c."isActive" = true
      ORDER BY p.id
    `;

    const projects = await this.dataSource.query(query);
    console.log(`üéØ Found ${projects.length} active projects`);
    
    return projects.map((p: any) => ({
      id: p.id,
      name: p.name
    }));
  }

  /**
   * Get last recorded entry from somnia_dreamathon_miner_points for any project
   */
  async getLastRecordedEntry(walletAddress: string): Promise<SomniaDreamathonMinerPoints | null> {
    const repo = this.dataSource.getRepository(SomniaDreamathonMinerPoints);
    
    const latestEntry = await repo.findOne({
      where: { walletAddress: walletAddress.toLowerCase() },
      order: { createdAt: 'DESC' }
    });

    console.log(`  üìã Last Recorded Entry: ${latestEntry ? `Found (${latestEntry.createdAt.toISOString()})` : 'None found (new miner)'}`);
    
    return latestEntry;
  }

  /**
   * Get content generated by project since timestamp (ONLY dedicated miner content)
   * Counts 'completed' entries in dedicated_miner_executions table
   */
  async getContentGeneratedByProject(walletAddress: string, sinceTimestamp: Date): Promise<Map<number, number>> {
    // Count completed dedicated miner executions grouped by project
    const query = `
      SELECT c."projectId", COUNT(dme.id) as content_count
      FROM dedicated_miner_executions dme
      INNER JOIN campaigns c ON dme.campaign_id = c.id
      WHERE LOWER(dme.miner_wallet_address) = LOWER($1)
        AND dme.status = 'completed'
        AND dme.created_at >= $2
        AND c."projectId" IS NOT NULL
      GROUP BY c."projectId"
    `;

    const results = await this.dataSource.query(query, [walletAddress, sinceTimestamp]);
    
    const projectContentMap = new Map<number, number>();
    for (const row of results) {
      projectContentMap.set(row.projectId, parseInt(row.content_count));
      console.log(`    Project ${row.projectId}: ${row.content_count} content pieces generated (dedicated mining only)`);
    }
    
    return projectContentMap;
  }

  /**
   * Get sales data by project since timestamp
   */
  async getSalesDataByProject(
    walletAddress: string, 
    sinceTimestamp: Date
  ): Promise<Map<number, { contentSold: number; salesRevenue: number; revenueShare: number }>> {
    const query = `
      SELECT 
        c."projectId",
        COUNT(DISTINCT cp.id) as content_sold,
        COALESCE(SUM(cp.purchase_price), 0) as total_revenue
      FROM content_purchases cp
      INNER JOIN content_marketplace cm ON cp.content_id = cm.id
      INNER JOIN campaigns c ON cm."campaignId" = c.id
      WHERE LOWER(cm."minerWallet") = LOWER($1)
        AND cp.payment_status = 'completed'
        AND cp.created_at >= $2
        AND c."projectId" IS NOT NULL
      GROUP BY c."projectId"
    `;

    const results = await this.dataSource.query(query, [walletAddress, sinceTimestamp]);
    
    const projectSalesMap = new Map();
    for (const row of results) {
      const totalRevenue = parseFloat(row.total_revenue);
      const revenueShare = totalRevenue * REVENUE_SHARE_PERCENTAGE;
      projectSalesMap.set(row.projectId, {
        contentSold: parseInt(row.content_sold),
        salesRevenue: totalRevenue,
        revenueShare: revenueShare
      });
      console.log(`    Project ${row.projectId}: ${row.content_sold} sold, Revenue: ${totalRevenue} $ROAST, Share: ${revenueShare} $ROAST`);
    }
    
    return projectSalesMap;
  }

  /**
   * Process a single miner for a specific project
   */
  async processMinerForProject(
    miner: MinerWallet, 
    projectId: number,
    sinceTimestamp: Date,
    contentCount: number,
    salesData: { contentSold: number; salesRevenue: number; revenueShare: number }
  ): Promise<MinerCalculation> {
    const calculation: MinerCalculation = {
      walletAddress: miner.walletAddress,
      projectId,
      name: undefined, // Can be populated if user data is available
      dailyContentGenerated: contentCount,
      dailyContentSold: salesData.contentSold,
      dailySalesRevenue: salesData.salesRevenue,
      dailyRevenueShare: salesData.revenueShare,
      weeklyUptimeRewards: 0, // Will be calculated on Tuesdays
      weeklyTopSellerBonus: 0, // Will be calculated on Tuesdays
      grandPrizeRewards: 0,
      dailySalesRank: undefined,
      weeklyTopSellerRank: 0,
      overallRank: undefined
    };
    
    return calculation;
  }

  /**
   * Save miner daily points
   */
  async saveMinerDailyPoints(calculation: MinerCalculation): Promise<void> {
    const repo = this.dataSource.getRepository(SomniaDreamathonMinerPoints);

    const minerPoints = new SomniaDreamathonMinerPoints();
    minerPoints.walletAddress = calculation.walletAddress;
    minerPoints.projectId = calculation.projectId;
    minerPoints.name = calculation.name;
    minerPoints.dailyUptimePercentage = 0; // Not populated (calculated on-demand)
    minerPoints.dailyContentGenerated = calculation.dailyContentGenerated;
    minerPoints.dailyContentSold = calculation.dailyContentSold;
    minerPoints.dailySalesRevenue = calculation.dailySalesRevenue;
    minerPoints.dailyRevenueShare = calculation.dailyRevenueShare;
    minerPoints.weeklyUptimeRewards = calculation.weeklyUptimeRewards;
    minerPoints.weeklyTopSellerBonus = calculation.weeklyTopSellerBonus;
    minerPoints.grandPrizeRewards = calculation.grandPrizeRewards;
    minerPoints.dailySalesRank = calculation.dailySalesRank;
    minerPoints.weeklyTopSellerRank = calculation.weeklyTopSellerRank;
    minerPoints.overallRank = calculation.overallRank;

    await repo.save(minerPoints);
  }

  /**
   * Check if today is Tuesday (weekly calculation day)
   */
  private isWeeklyCalculationDay(): boolean {
    const today = new Date();
    return today.getDay() === 2; // Tuesday = 2
  }

  /**
   * Calculate weekly rewards (called on Tuesdays)
   */
  async calculateWeeklyRewards(): Promise<void> {
    console.log('üóìÔ∏è Calculating weekly rewards (Tuesday calculation)...');
    
    // Get weekly calculation window (last Tuesday to this Tuesday)
    const today = new Date();
    const lastTuesday = new Date(today);
    lastTuesday.setDate(lastTuesday.getDate() - 7);
    lastTuesday.setHours(15, 0, 0, 0); // 10 AM ET = 3 PM UTC
    
    const thisTuesday = new Date(today);
    thisTuesday.setHours(15, 0, 0, 0);
    
    console.log(`üìÖ Weekly window: ${lastTuesday.toISOString()} to ${thisTuesday.toISOString()}`);
    
    // 1. Calculate uptime rewards (450K divided equally among nodes with 95%+ uptime)
    // Calculate uptime directly from dedicated_miner_executions (not from stored dailyUptimePercentage)
    const uptimeQuery = `
      SELECT 
        LOWER("walletAddress") as "walletAddress",
        COUNT(*) as total_attempts,
        SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) as successful_attempts,
        (SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END)::decimal / NULLIF(COUNT(*), 0)::decimal * 100) as uptime_percentage
      FROM dedicated_miner_executions
      WHERE "createdAt" >= $1 AND "createdAt" < $2
      GROUP BY LOWER("walletAddress")
      HAVING (SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END)::decimal / NULLIF(COUNT(*), 0)::decimal * 100) >= $3
    `;
    
    const qualifyingMiners = await this.dataSource.query(uptimeQuery, [lastTuesday, thisTuesday, MIN_UPTIME_FOR_REWARDS]);
    
    // Filter out excluded wallets
    const eligibleForUptime = qualifyingMiners.filter((m: any) => !this.isWalletExcludedFromRewards(m.walletAddress));
    
    console.log(`üìä Found ${qualifyingMiners.length} miners with ${MIN_UPTIME_FOR_REWARDS}%+ uptime, ${eligibleForUptime.length} eligible`);
    
    if (eligibleForUptime.length > 0) {
      const uptimeRewardPerMiner = Math.floor(WEEKLY_UPTIME_POOL / eligibleForUptime.length);
      
      // Update uptime rewards for all records of qualifying miners in this weekly window
      for (const miner of eligibleForUptime) {
        await this.dataSource.query(`
          UPDATE somnia_dreamathon_miner_points
          SET "weeklyUptimeRewards" = $1
          WHERE LOWER("walletAddress") = LOWER($2)
            AND "createdAt" >= $3 
            AND "createdAt" < $4
        `, [uptimeRewardPerMiner, miner.walletAddress, lastTuesday, thisTuesday]);
        
        console.log(`üí∞ Uptime reward: ${miner.walletAddress} (${parseFloat(miner.uptime_percentage).toFixed(2)}% uptime) = ${uptimeRewardPerMiner} $ROAST`);
      }
    }
    
    // 2. Calculate top seller bonus (1M distributed proportionally)
    const salesQuery = `
      SELECT "walletAddress", SUM("dailySalesRevenue") as total_sales
      FROM somnia_dreamathon_miner_points
      WHERE "createdAt" >= $1 AND "createdAt" < $2
      GROUP BY "walletAddress"
      HAVING SUM("dailySalesRevenue") > 0
      ORDER BY total_sales DESC
    `;
    
    const allSellers = await this.dataSource.query(salesQuery, [lastTuesday, thisTuesday]);
    
    // Filter out excluded wallets
    const eligibleSellers = allSellers.filter((m: any) => !this.isWalletExcludedFromRewards(m.walletAddress));
    
    if (eligibleSellers.length > 0) {
      const totalSales = eligibleSellers.reduce((sum: number, m: any) => sum + parseFloat(m.total_sales), 0);
      
      console.log(`üìä Found ${eligibleSellers.length} sellers with total sales: ${totalSales} $ROAST`);
      
      // Distribute 1M proportionally
      for (let i = 0; i < eligibleSellers.length; i++) {
        const miner = eligibleSellers[i];
        const proportion = parseFloat(miner.total_sales) / totalSales;
        const topSellerBonus = Math.round(proportion * WEEKLY_TOP_SELLER_POOL);
        
        await this.dataSource.query(`
          UPDATE somnia_dreamathon_miner_points
          SET "weeklyTopSellerBonus" = $1,
              "weeklyTopSellerRank" = $2
          WHERE LOWER("walletAddress") = LOWER($3)
            AND "createdAt" >= $4 
            AND "createdAt" < $5
        `, [topSellerBonus, i + 1, miner.walletAddress, lastTuesday, thisTuesday]);
        
        console.log(`üèÜ Rank ${i + 1}: ${miner.walletAddress} - ${parseFloat(miner.total_sales).toFixed(2)} sales = ${topSellerBonus} bonus`);
      }
    }
    
    console.log(`‚úÖ Weekly rewards calculated and distributed`);
  }

  /**
   * Print dry run summary table
   */
  printDryRunSummary(): void {
    console.log('\n' + '='.repeat(200));
    console.log('üìä DRY RUN SUMMARY - MINER POINTS BREAKDOWN');
    console.log('='.repeat(200));
    
    // Header
    console.log(
      'Wallet Address'.padEnd(45) + 
      'Project'.padEnd(10) + 
      'Content Gen'.padEnd(13) + 
      'Content Sold'.padEnd(14) + 
      'Sales Rev'.padEnd(12) + 
      'Rev Share (70%)'.padEnd(18) + 
      'Total'
    );
    console.log('-'.repeat(200));
    
    // Group by wallet for summary
    const walletTotals = new Map<string, {
      contentGen: number;
      contentSold: number;
      salesRev: number;
      revShare: number;
    }>();
    
    // Sort by wallet address
    const sorted = [...this.allCalculations].sort((a, b) => 
      a.walletAddress.localeCompare(b.walletAddress)
    );
    
    // Print each record
    for (const calc of sorted) {
      const wallet = calc.walletAddress;
      const projectId = calc.projectId?.toString() || 'N/A';
      
      console.log(
        wallet.padEnd(45) +
        projectId.padEnd(10) +
        calc.dailyContentGenerated.toString().padEnd(13) +
        calc.dailyContentSold.toString().padEnd(14) +
        calc.dailySalesRevenue.toFixed(2).padEnd(12) +
        calc.dailyRevenueShare.toFixed(2).padEnd(18) +
        calc.dailyRevenueShare.toFixed(2)
      );
      
      // Accumulate totals per wallet
      if (!walletTotals.has(wallet)) {
        walletTotals.set(wallet, {
          contentGen: 0,
          contentSold: 0,
          salesRev: 0,
          revShare: 0
        });
      }
      const totals = walletTotals.get(wallet)!;
      totals.contentGen += calc.dailyContentGenerated;
      totals.contentSold += calc.dailyContentSold;
      totals.salesRev += calc.dailySalesRevenue;
      totals.revShare += calc.dailyRevenueShare;
    }
    
    console.log('='.repeat(200));
    
    // Overall summary
    const totalContentGen = this.allCalculations.reduce((sum, calc) => sum + calc.dailyContentGenerated, 0);
    const totalContentSold = this.allCalculations.reduce((sum, calc) => sum + calc.dailyContentSold, 0);
    const totalSalesRev = this.allCalculations.reduce((sum, calc) => sum + calc.dailySalesRevenue, 0);
    const totalRevShare = this.allCalculations.reduce((sum, calc) => sum + calc.dailyRevenueShare, 0);
    
    console.log(`TOTALS: ${this.allCalculations.length} recs`.padEnd(55) + 
      totalContentGen.toString().padEnd(13) + 
      totalContentSold.toString().padEnd(14) + 
      totalSalesRev.toFixed(2).padEnd(12) + 
      totalRevShare.toFixed(2).padEnd(18) + 
      totalRevShare.toFixed(2)
    );
    console.log('='.repeat(200));
    
    // Statistics
    console.log('\nüìà Summary Statistics:');
    console.log(`   Total Miners: ${walletTotals.size}`);
    console.log(`   Total Project Records: ${this.allCalculations.length}`);
    console.log(`   Avg Records per Miner: ${(this.allCalculations.length / walletTotals.size).toFixed(2)}`);
    console.log(`   Total Content Generated: ${totalContentGen}`);
    console.log(`   Total Content Sold: ${totalContentSold}`);
    console.log(`   Total Sales Revenue: ${totalSalesRev.toFixed(2)} $ROAST`);
    console.log(`   Total Revenue Share (70%): ${totalRevShare.toFixed(2)} $ROAST`);
    console.log('='.repeat(200));
  }

  /**
   * Main execution function
   */
  async run(dryRun: boolean = false): Promise<void> {
    try {
      console.log('üöÄ Starting Somnia Dreamathon Miner Points Calculation Script');
      console.log('üìÖ Date:', new Date().toISOString());
      console.log(`üîß Mode: ${dryRun ? 'DRY RUN' : 'LIVE'}`);

      // Check if within campaign period
      if (!this.isWithinCampaignPeriod()) {
        console.log('‚ö†Ô∏è Current date is outside campaign period (Nov 18 - Dec 9, 2025)');
        console.log('   Exiting script');
        return;
      }

      // Initialize database connection
      if (!this.dataSource.isInitialized) {
        await this.dataSource.initialize();
        console.log('‚úÖ Database connected');
      }

      // Get all miners
      const miners = await this.getMiners();
      console.log(`üìä Found ${miners.length} miners`);

      if (miners.length === 0) {
        console.log('‚ö†Ô∏è No miners found. Exiting.');
        return;
      }

      // Get all active projects
      const projects = await this.getActiveProjects();

      // Process each miner
      let totalProjectRecords = 0;
      for (const miner of miners) {
        try {
          console.log(`\nüë§ Processing miner: ${miner.walletAddress}`);
          
          // Get last recorded entry
          const lastEntry = await this.getLastRecordedEntry(miner.walletAddress);
          
          // Calculate sinceTimestamp (never before campaign start)
          const sinceTimestamp = lastEntry 
            ? new Date(Math.max(lastEntry.createdAt.getTime(), CAMPAIGN_START_DATE.getTime()))
            : CAMPAIGN_START_DATE;
          
          const now = new Date();
          const daysSinceLastRun = Math.ceil((now.getTime() - sinceTimestamp.getTime()) / (1000 * 60 * 60 * 24));
          
          console.log(`  üìÖ Calculating since: ${sinceTimestamp.toISOString()} (${daysSinceLastRun} days ago)`);
          
          // Get content and sales data by project
          console.log(`  üìä Fetching content generated by project...`);
          const contentByProject = await this.getContentGeneratedByProject(miner.walletAddress, sinceTimestamp);
          
          console.log(`  üìä Fetching sales data by project...`);
          const salesByProject = await this.getSalesDataByProject(miner.walletAddress, sinceTimestamp);
          
          // Get all projects this miner has activity for
          const activeProjectIds = new Set([
            ...contentByProject.keys(),
            ...salesByProject.keys()
          ]);
          
          if (activeProjectIds.size === 0) {
            console.log(`  ‚ö†Ô∏è No activity found for this miner since ${sinceTimestamp.toISOString()}`);
            continue;
          }
          
          console.log(`  üéØ Miner has activity for ${activeProjectIds.size} projects`);
          
          // Create one record per project
          for (const projectId of activeProjectIds) {
            const contentCount = contentByProject.get(projectId) || 0;
            const salesData = salesByProject.get(projectId) || { 
              contentSold: 0, 
              salesRevenue: 0, 
              revenueShare: 0 
            };
            
            const calculation = await this.processMinerForProject(
              miner,
              projectId,
              sinceTimestamp,
              contentCount,
              salesData
            );
            
            if (dryRun) {
              this.allCalculations.push(calculation);
              console.log(`  üìä [DRY RUN] Project ${projectId}: Content=${contentCount}, Sold=${salesData.contentSold}, Revenue=${salesData.salesRevenue.toFixed(2)}`);
            } else {
              await this.saveMinerDailyPoints(calculation);
              console.log(`  ‚úÖ Saved record for project ${projectId}`);
            }
            
            totalProjectRecords++;
          }
          
          console.log(`  üìä Total: ${activeProjectIds.size} project records created`);
          
        } catch (error) {
          console.error(`‚ùå Error processing miner ${miner.walletAddress}:`, error);
        }
      }

      console.log(`\nüìä [${dryRun ? 'DRY RUN' : 'LIVE'}] Created ${totalProjectRecords} project records for ${miners.length} miners`);

      // Calculate daily ranks
      if (!dryRun) {
        // Calculate weekly rewards if it's Tuesday
        if (this.isWeeklyCalculationDay()) {
          console.log('\nüóìÔ∏è Tuesday detected - calculating weekly rewards...');
          await this.calculateWeeklyRewards();
        }
      } else {
        // Print dry run summary
        this.printDryRunSummary();
      }

      console.log(`\nüéâ Somnia Miner Points Calculation completed successfully!${dryRun ? ' [DRY RUN MODE]' : ''}`);

    } catch (error) {
      console.error('üí• Script failed:', error);
      throw error;
    } finally {
      // Clean up database connection
      if (this.dataSource.isInitialized) {
        await this.dataSource.destroy();
        console.log('‚úÖ Database connection closed');
      }
    }
  }
}

// Script execution
async function main() {
  // Parse command line arguments
  let useSSL: boolean | undefined;
  let dryRun: boolean = false;
  
  for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];
    
    if (arg === '--ssl') {
      useSSL = true;
    } else if (arg === '--no-ssl') {
      useSSL = false;
    } else if (arg === '--dry-run') {
      dryRun = true;
    }
  }

  // Determine SSL usage
  let sslEnabled: boolean;
  if (useSSL !== undefined) {
    sslEnabled = useSSL;
  } else {
    sslEnabled = process.env.NODE_ENV === 'production' || 
                 process.env.DB_HOST?.includes('rds.amazonaws.com') || 
                 false;
  }

  // Create database connection
  AppDataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST || '127.0.0.1',
    port: parseInt(process.env.DB_PORT || '5434'),
    username: process.env.DB_USERNAME || 'postgres',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'roastpower',
    entities: [SomniaDreamathonMinerPoints],
    synchronize: false,
    logging: process.env.DB_LOGGING === 'true',
    ssl: sslEnabled ? { rejectUnauthorized: false } : false,
    extra: {
      connectionLimit: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 10000,
    },
  });
  
  console.log('üîß Configuration:');
  console.log(`   Database: ${process.env.DB_HOST}:${process.env.DB_PORT}/${process.env.DB_NAME}`);
  console.log(`   SSL: ${sslEnabled ? 'Enabled' : 'Disabled'}`);
  console.log(`   Mode: ${dryRun ? 'DRY RUN' : 'LIVE'}`);
  console.log(`   Campaign: Nov 18 - Dec 9, 2025`);
  console.log('');

  const script = new SomniaDailyPointsMinerScript(AppDataSource);
  
  try {
    await script.run(dryRun);
    process.exit(0);
  } catch (error) {
    console.error('Script execution failed:', error);
    process.exit(1);
  }
}

// Run the script if executed directly
if (require.main === module) {
  main().catch(console.error);
}

export { SomniaDailyPointsMinerScript };

